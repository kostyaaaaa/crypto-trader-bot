# `analyze-funding` — модуль аналізу Funding Rate (Binance Perpetuals)

> **Призначення:** дати простий, інтерпретований сигнал ринкового перекосу (балансу LONG/SHORT) через **Funding Rate** з Binance і перетворити його у `LONG` / `SHORT` / `NEUTRAL` з оцінкою сили.  
> **Ідея:** якщо **середній funding > 0**, більшість тримають **LONG**, отже модуль повертає **контр-трендовий** сигнал `SHORT`. Якщо **середній funding < 0** — навпаки, повертає `LONG`.

---

## 1) Що робить модуль

- Тягне сирі значення **Funding Rate** по інструменту з Binance REST API:
  - endpoint: `/fapi/v1/fundingRate`
  - параметри: `symbol`, `limit` (кількість останніх записів)
- Кожен запис funding відповідає **8 годинам**. Отже `window` із N записів ≈ покриває `N × 8 год`.
- Розраховує **середній funding** за вибраний період (просте середнє).
- На основі знаку середнього funding формує **сигнал** і **бали сили** (`longScore`, `shortScore`) у шкалі 0–100.
- Повертає компактний об’єкт із `signal`, `strength` та корисним `meta` для логів/дашборду.

> Якщо даних немає або їх недостатньо (`candles.length < window`), модуль повертає `null` (щоб не ухвалювати рішення на «дірявих» даних).

---

## 2) Як це впливає на рішення бота

- **Funding > 0** → ринок **перекошений у LONG** (лонги платять шортам) → модуль дає **`SHORT`** як контр-сигнал.
- **Funding < 0** → ринок **перекошений у SHORT** → модуль дає **`LONG`**.
- **Funding ≈ 0** → **`NEUTRAL`**.

Практичні застосування:

- **Фільтр входів**: не відкривати LONG, якщо funding стабільно дуже позитивний (натовп і так у лонгах).
- **Комбінування з трендом**: якщо трендовий модуль за LONG, а funding сильно позитивний (дає SHORT), можна зменшити розмір або зачекати балансування.
- **Ризик-менеджмент**: масштабувати позицію залежно від `strength`.

---

## 3) Чому це важливо

1. **Funding — безпосередня «ціна дисбалансу» позицій** у перпетуалах. Це реальні гроші, які платять одна сторона іншій — тому метрика менш «шумна», ніж деякі похідні індикатори.
2. **Контрнатовповий індикатор**: допомагає уникати «переповнених» сторін ринку, де ризик різких ліквідацій і «сквізів» вищий.
3. **Простота та інтерпретованість**: один знак/середнє і прозорий спосіб скорингу — легко логувати, дебажити, презентувати.

---

## 4) Покроково: як працює код

1. **HTTP-запит до Binance**

   ```js
   const url = 'https://fapi.binance.com/fapi/v1/fundingRate';
   const res = await axios.get(url, {
     params: { symbol, limit: window },
   });
   ```

   Отримуємо останні `window` записів funding для `symbol`.

2. **Перевірка відповіді**

   ```js
   if (!res.data || res.data.length === 0) return null;
   ```

   Якщо немає даних — завершуємо.

3. **Оцінка покритого періоду**

   ```js
   const hoursCovered = window * 8;
   const daysCovered = (hoursCovered / 24).toFixed(1);
   ```

   Кожне значення — за 8 годин; це дає нам зрозуміти, який часовий інтервал ми аналізуємо (для мета-інформації).

4. **Нормалізація записів у «свічки» funding**

   ```js
   const candles = res.data.map((fr) => ({
     symbol,
     time: new Date(fr.fundingTime).toISOString(),
     fundingRate: parseFloat(fr.fundingRate),
   }));
   if (candles.length < window) return null;
   ```

   Перетворюємо у зручний формат і ще раз перевіряємо повноту вибірки.

5. **Середній funding**

   ```js
   const avgFunding =
     candles.reduce((s, c) => s + (c.fundingRate || 0), 0) / candles.length;
   ```

   Базова середня — проста й достатня для першої ітерації.

6. **Формування сигналу і балів**

   ```js
   let signal = 'NEUTRAL';
   let longScore = 50;
   let shortScore = 50;

   if (avgFunding > 0) {
     signal = 'SHORT';
     shortScore = Math.min(100, 50 + avgFunding * 1000);
     longScore = 100 - shortScore;
   } else if (avgFunding < 0) {
     signal = 'LONG';
     longScore = Math.min(100, 50 + Math.abs(avgFunding) * 1000);
     shortScore = 100 - longScore;
   }
   ```

   - Початкова база — **50/50** (нейтрально).
   - Далі зміщуємо у бік, протилежний знаку funding.
   - **Масштабування `×1000`** переводить типові дрібні значення funding (близько 0.0001…0.005) у відчутний діапазон балів.
   - Обмежуємо верх «стелею» 100 і симетрично коригуємо протилежний бік.

7. **Округлення та підсумок**

   ```js
   const roundedLong = Math.round(longScore);
   const roundedShort = Math.round(shortScore);

   return {
     module: 'funding',
     symbol,
     signal,
     strength: Math.max(roundedLong, roundedShort),
     meta: {
       LONG: roundedLong,
       SHORT: roundedShort,
       candlesUsed: candles.length,
       avgFunding: parseFloat(avgFunding.toFixed(5)),
       periodCovered: `${hoursCovered}h (~${daysCovered} days)`,
     },
   };
   ```

   - `strength` — максимальне з двох балів (0–100).
   - `meta` включає скільки записів використано, середній funding (5 знаків) і покритий період.

8. **Обробка помилок**
   ```js
   } catch (e) {
     console.error('Funding fetch/analyze error...', e.message);
     return null;
   }
   ```
   У разі мережевих/API проблем модуль поводиться безпечно (повертає `null`).

---

## 5) Вхідні та вихідні дані

### Вхід

```ts
symbol?: string   // за замовчуванням 'ETHUSDT'
window?: number   // кількість останніх funding-записів (за замовчуванням 60)
```

> **Примітка:** 1 запис = 8 годин. Напр., `window = 60` ≈ **480 годин** ≈ ~**20 днів**.

### Вихід

```ts
null |
  {
    module: 'funding',
    symbol: string,
    signal: 'LONG' | 'SHORT' | 'NEUTRAL',
    strength: number, // 0..100
    meta: {
      LONG: number, // округлені бали лонга
      SHORT: number, // округлені бали шорта
      candlesUsed: number, // скільки записів використано
      avgFunding: number, // середній funding (5 знаків)
      periodCovered: string, // напр. "480h (~20.0 days)"
    },
  };
```

---

## 6) Приклад поверненого значення

```json
{
  "module": "funding",
  "symbol": "SOLUSDT",
  "signal": "SHORT",
  "strength": 68,
  "meta": {
    "LONG": 32,
    "SHORT": 68,
    "candlesUsed": 60,
    "avgFunding": 0.00018,
    "periodCovered": "480h (~20.0 days)"
  }
}
```

> **Пояснення:** середній funding позитивний (+0.00018), отже натовп у LONG, модуль повертає `SHORT` із силою 68.

---

## 7) Налаштування й тюнінг

- **Вікно `window`**: більше значення → стабільніша середня, але повільніша реакція; менше → швидша реакція, більше шуму. Типово 30–90.
- **Масштаб `×1000`**: підібрано емпірично для зручної шкали 0–100. Можна змінити на `×800`/`×1200` залежно від бажаної чутливості.
- **Пороги використання**: наприклад, вважати сигнал «сильним», якщо `strength ≥ 60`.
- **Згладжування**: замість простого середнього можна взяти **EMA** по funding або **усічене середнє** (відкинути топ- та нижні 5%) для захисту від аномальних сплесків.

---

## 8) Застереження та крайні випадки

- **Стійко позитивний funding у бичих фазах**: позитивний funding може триматись тижнями — це не означає негайний розворот. Тому модуль краще **комбінувати з трендовим** (EMA/RSI) та волатильністю.
- **API-ліміти та тимчасові збої**: при помилках модуль повертає `null`. Варто мати retry/бекоф на рівні виклику.
- **Різні біржі, різні методики**: тут використовується **Binance USDT-M ф’ючерси**; на інших біржах формули/цикли нарахування можуть відрізнятися.
- **Нуль/NaN у відповіді**: перевіряйте, щоб `fundingRate` коректно парсився (в коді є `parseFloat`).
- **Зміна бази**: час від часу Binance може змінювати обмеження `limit` або формат — тримайте це у тестах.

---

## 9) Де й як використовувати у боті

- **Як фільтр**: не брати LONG, якщо funding сильно > 0 і `strength` високий; не брати SHORT при сильно негативному funding.
- **Як вагу в ансамблі**: агрегувати з модулем тренду, волатильності, об’єму; робити зважене рішення за кількома джерелами.
- **Як модифікатор розміру**: масштабувати ризик/позицію залежно від сили перекосу ринку.

---

## 10) TL;DR для нетехнічних

- Ми дивимось, **хто платить кому** у ф’ючерсах: якщо платять лонги — значить, **лонгів багато**.
- Беремо середнє за N останніх нарахувань (кожне — 8 годин).
- Позитивне середнє → натовп у LONG → ми отримуємо **контр-сигнал `SHORT`**; негативне → **`LONG`**.
- Видаємо напрямок і **силу (0–100)**, яку можна використовувати для фільтрації та ризик-менеджменту.
