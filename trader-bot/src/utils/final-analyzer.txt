

Що входить на вхід і де це береться

Функція не приймає “сирі” дані — вона читає готові агрегати з файлів, які ти наповнюєш іншими кроками:
    •	candles.json — хвилинні свічки (open/high/low/close/volume + за бажанням fundingRate). Пише TickerStepWS.
	•	liquidity.json — хвилинні “ліквідність-свічки” з order book (avgImbalance, avgSpread, сигнал). Пише OrderBookStepWS.
	•	liquidations.json — хвилинні “свічки ліквідацій” (суми buy/sell liquidations, сигнал). Пише LiquidationsStepWS.
	•	openinterest.json — 5-хв OI (openInterest, openInterestValue, price). Пише OpenInterestStep.
	•	longshort.json — глобальне long/short ratio (не обов’язково у фінальному скорингу, але корисно для дебагу). Пише LongShortRatioStep.
	•	btc.json — хвилинні свічки BTC для кореляції. Пише BtcStepWS.
	•	funding.json (за бажанням) — історія funding rate; або ти зберігаєш funding в candles.json і тоді analyzeFunding читає звідти.

    Кожен блок і його вплив

1) Trend (EMA/RSI) — читає candles.json
	•	analyzeCandles() робить EMA(9) і EMA(21) по close, RSI(14).
	•	Якщо emaFast > emaSlow → тренд ап, додаємо trendLONG += 70, інакше trendSHORT += 70.
	•	Якщо RSI < 30 → перепроданість, trendLONG += 30; якщо RSI > 70 → trendSHORT += 30.
	•	Вихід: trendLONG, trendSHORT у шкалі 0…100 (типова розкладка 70/30).

Що це означає: наскільки ціна трендово підтримує LONG або SHORT.

2) Liquidity (order book) — читає liquidity.json
	•	analyzeLiquidity(liqWindow) бере останні liqWindow хвилин.
	•	Рахує avgImbalance (частка bid проти сумарної bid+ask) і avgSpread.
	•	Якщо avgImbalance > 0.55 → signal = LONG, якщо < 0.45 → SHORT, інакше NEUTRAL.
	•	У фіналі: якщо LONG → liqLONG = 100, якщо SHORT → liqSHORT = 100.

Що це означає: дисбаланс у стакані. Більше грошей у bid → штовхає вгору (LONG), в ask → вниз (SHORT). Spread дає якість ліквідності (вузький — краще).

3) Funding sentiment — читає funding.json або candles.json (залежить від твоєї реалізації analyzeFunding)
•	analyzeFunding(fundingWindow) усереднює funding за вікно (напр. 60 хв).
•	Якщо avgFunding > 0.05% → перегріті лонги, sentSHORT = 100.
	•	Якщо avgFunding < -0.05% → перегріті шорти, sentLONG = 100.
	•	Інакше sentLONG = 50, sentSHORT = 50 (нейтрально).

    Що це означає: “натовп” зазвичай платить у бік тренду. Завищений funding часто працює як контр-сигнал.

4) Liquidations — читає liquidations.json
	•	analyzeLiquidations(liqSentWindow) порівнює суму ліквідацій шортів (buy-side) проти лонгів (sell-side) за вікно.
	•	Якщо за обсягом шорт-ліквідацій >60% → LONG (ринок вибив шорти, потенційний відскок вгору).
•	Якщо лонг-ліквідацій >60% → SHORT.
	•	У фіналі виставляємо liqSentLONG / liqSentSHORT.

    Що це означає: масові ліквідації — це часто екстремум і можливий розворот/відскок.

5) Open Interest (OI + ціна) — читає openinterest.json
	•	analyzeOpenInterest(oiWindow) дивиться динаміку openInterest і ціни між першою і останньою свічкою у вікні.
	•	Логіка:
    •	OI ↑ + Price ↑ → LONG (входить новий капітал у напрямку росту).
•	OI ↑ + Price ↓ → SHORT (набирають шорти).
•	OI ↓ + Price ↑ → SHORT (рух ціни може бути “на ліквідаціях”, без підтримки).
•	OI ↓ + Price ↓ → LONG (short covering / вихід шортів).
•	У фіналі: oiLONG / oiSHORT.

    Що це означає: чи підтверджує новий капітал (OI) поточний рух ціни.

6) Volatility (ATR) — читає candles.json
	•	analyzeVolatility(volWindow) → рахує ATR і ATR% від ціни.
	•	Якщо ATR% < 0.2% → signal = DEAD → миттєво NO TRADE (ринок “мертвий”, шум з’їсть сигнал).

Що це означає: фільтр неліктвдних/тихих фаз, де краще не торгувати.

7) Correlation with BTC — читає btc.json + групу з correlation-config.js
	•	analyzeCorrelation(symbol, corrWindow) рахує % зміни ціни BTC за вікно.
	•	Якщо BTC > +0.5% → сигнал LONG, якщо < −0.5% → SHORT.
	•	Далі множимо сигнал на вагу з групи (strong=1.0, medium=0.6, weak=0.3), залежно від символу:
    •	strong (ETH, SOL, BNB, ADA…) — BTC сильно впливає;
	•	medium / weak — вплив слабший.
	•	У фіналі: corrLONG / corrSHORT = 100 * weight при відповідному знаку.

    Що це означає: якщо BTC валиться, краще не лонгити корельовані альти; якщо BTC тягне — не йти проти.



Як збирається підсумок (скоринг)

Після кожного блоку ми маємо вагові бали (0…100) для LONG і для SHORT. Далі підсумок:

    weightedScore =
        trend * 0.25 +
        liq   * 0.20 +
        sent  * 0.15 +
        liqSent * 0.15 +
        oi    * 0.15 +
        corr  * 0.10

	•	trend — теханаліз (EMA/RSI)
	•	liq — стакан
	•	sent — funding sentiment
	•	liqSent — ліквідації
	•	oi — open interest + ціна
	•	corr — вплив BTC

Отримуєш scoreLONG і scoreSHORT.
    Далі пороги:
    •	Якщо scoreLONG > 65 → LONG
	•	Якщо scoreSHORT > 65 → SHORT
	•	Інакше → NO TRADE

Поріг 65 і ваги — тюнінгові. Їх треба підбирати під твою стратегію (бек-тести).

Що пишеться в analysis.json

Ми додаємо об’єкт:
{
  "time": "UTC-timestamp",
    "symbol": "ETHUSDT",
    "trendLONG": 0-100,
    "trendSHORT": 0-100,
    "liqLONG": 0-100,
    "liqSHORT": 0-100,
    "sentLONG": 0-100,
    "sentSHORT": 0-100,
    "liqSentLONG": 0-100,
    "liqSentSHORT": 0-100,
    "oiLONG": 0-100,
    "oiSHORT": 0-100,
    "corrLONG": 0-100,
    "corrSHORT": 0-100,
    "scoreLONG": 0-100,
    "scoreSHORT": 0-100,
    "decision": "LONG|SHORT|NO TRADE|NO TRADE (LOW VOLATILITY)"
}
Це зручно для аудиту/моніторингу, ідеально — графикою дивитись динаміку компонентів скори.

    Який блок на що впливає (швидка мапа)
•	Trend (EMA/RSI) → напрямок ціни (базова тенденція).
•	Liquidity (imbalance/spread) → “натиск” у стакані тут і зараз.
	•	Funding → “перегрів” боку; контр-індикатор (високий funding проти тренду).
•	Liquidations → екстремуми/вибивання плечей; контр-індикатор короткостроково.
	•	Open Interest + Price → підтвердження чи якість руху (капітал заходить/виходить).
•	Volatility (ATR) → фільтр мертвого ринку (NO TRADE).
•	BTC correlation → макро-фон; краще не йти проти BTC для сильно корельованих альтів.

    Коли що може бути порожнім / edge cases
	•	Якщо даних мало (наприклад, щойно стартанули), блок поверне null або 0-бали → це нормально: інші блоки все одно порахуються. Коли даних назбирається достатньо (по вікну) — блок автоматично “увімкнеться”.
•	Якщо ATR DEAD → миттєво NO TRADE (навіть якщо інші блоки “за”).

Тюнінг, щоб було “максимально правильно”
	•	Пороги: 0.55/0.45 для imbalance, 65 для рішення, 0.5% для BTC — це стартові значення. Під стратегію краще підібрати на історії.
	•	Вікна: для скальпінгу зменшити, для свінгу збільшити.
	•	Ваги: якщо торгуєш трендові фази — підніми вагу trend і oi. Якщо контр-тренд — підніми вагу liquidations і зменши trend.
	•	Анти-дрижання: додай гістерезис (наприклад, вимагаємо дві підряд оцінки > 65, або різницю |scoreLONG - scoreSHORT| > 10), щоб сигнал не “перемикався” щохвилини.

    Життєвий цикл
1.	Потоки (TickerStepWS, OrderBookStepWS, LiquidationsStepWS, BtcStepWS) постійно пишуть хвилинні/5-хв дані у свої файли.
2.	Періодично (наприклад, кожні 5 хв) викликається finalAnalyzer(...).
3.	finalAnalyzer читає останні X хвилин/свічок з кожного файлу, рахує блоки, змішує вагами, відсікає мертвий ринок (ATR), видає decision і лог зберігається в analysis.json.

    Чому саме так
	•	Ми комбінуємо напрям тренду, якість ліквідності, позиціонування ринку (funding, OI, liquidations) і макро-фон (BTC).
	•	Кожен блок дає свою незалежну ознаку, а підсумок — зважений консенсус. Так менше шансів “купити вершину”, ніж якщо дивитись тільки на один індикатор.